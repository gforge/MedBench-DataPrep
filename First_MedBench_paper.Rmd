---
title: "First MedBench paper"
author: "Max Gordon"
date: "2024-09-18"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
library(tidyverse)
library(Gmisc)
library(jsonlite)
library(reticulate)
library(glue)
```

```{r, include=FALSE}
py_config()
```

# Basics

```{r}
# Load the data
raw <- read_file("data/output/allData.json") |> fromJSON(simplifyVector = FALSE)
cases <- raw |> 
  map(\(x) x$charts |> 
        keep(\(c) length(c$summaries) > 1) |> 
        map(\(c) list(name = x$name,
                      specialty = x$specialty,
                      language = c$language,
                      summaries = c$summaries))) |> 
  discard(is_empty)

summaries <- cases |> 
  map(\(case) {
    map(case,
        \(chart) {
            map(chart$summaries,
                \(summary) list(name = chart$name,
                                specialty = chart$specialty,
                                chart_language = chart$language,
                                generatedBy = summary$generatedBy,
                                summary = summary$text)) |> 
            bind_rows()
        }) |> 
    bind_rows()
  }) |> 
  bind_rows()

reviews <- cases |> 
  map(\(case) {
    map(case,
        \(chart) {
            map(chart$summaries,
                \(summary) {
                  map(summary$reviews,
                      \(review) {
                        tibble(name = chart$name,
                               specialty = chart$specialty,
                               chart_language = chart$language,
                               generatedBy = summary$generatedBy,
                               reviewer = glue("{review$user$firstName} {review$user$lastName}")) |> 
                        bind_cols(as.data.frame(review$rating))
                      }) |> 
                    bind_rows() 
                  }) |> 
            bind_rows()
        }) |> 
    bind_rows()
  }) |> 
  bind_rows()
```

```{python, echo=FALSE}
from dataclasses import dataclass, asdict
import pandas as pd
from rouge import Rouge
from sacrebleu.metrics import BLEU

df = r.summaries

rouge = Rouge(metrics=['rouge-l'],
              max_n=2,
              limit_length=True,
              length_limit=100,
              length_limit_type='words',
              apply_avg=False,
              apply_best=False,
              alpha=0.5,  # Default F1_score
              stemming=True)
blue = BLEU(effective_order=True)

# Define the data structure for each result row
@dataclass
class SummaryResult:
    specialty: str
    name: str
    chart_language: str
    generatedBy: str
    rouge_l_f: float
    rouge_l_p: float
    rouge_l_r: float
    bleu_score: float
    bleu_bp: float

# Function to calculate scores and return a dataclass instance
def calculate_scores_and_store_results(
    human_summary: str, 
    generated_summary: str, 
    specialty: str, 
    name: str, 
    language: str, 
    generatedBy: str
) -> SummaryResult:
    # Compute ROUGE scores
    score = rouge.get_scores(generated_summary, human_summary)
    rouge_l = score['rouge-l'][0]
    
    # Compute BLEU scores
    bleu_score = blue.sentence_score(generated_summary, [human_summary])

    # Return an instance of SummaryResult dataclass
    return SummaryResult(
        specialty=specialty,
        name=name,
        chart_language=language,
        generatedBy=generatedBy,
        rouge_l_f=rouge_l['f'][0],
        rouge_l_p=rouge_l['p'][0],
        rouge_l_r=rouge_l['r'][0],
        bleu_score=bleu_score.score,
        bleu_bp=bleu_score.bp,
    )

# Main function to process the DataFrame
def retrieve_summary_text_scores(df: pd.DataFrame) -> pd.DataFrame:
    results: list[SummaryResult] = []

    # Iterate using groupby to avoid unnecessary nested loops
    for (specialty, language, name), df_case in df.groupby(['specialty', 'chart_language', 'name']):
        # Get the human summary
        human_summary_row = df_case[df_case['generatedBy'] == 'Human']
        if human_summary_row.empty:
            continue  # Skip if no human summary is available

        human_summary = human_summary_row['summary'].values[0]

        # Get the generated summaries (all except 'Human')
        generated_summaries = df_case[df_case['generatedBy'] != 'Human']

        for idx, row in generated_summaries.iterrows():
            # Calculate scores and store the result as a dataclass instance
            result = calculate_scores_and_store_results(
                human_summary=human_summary, 
                generated_summary=row['summary'],
                specialty=specialty, 
                name=name, 
                language=language, 
                generatedBy=row['generatedBy']
            )
            results.append(result)

    # Convert list of dataclass instances to DataFrame
    return pd.DataFrame([asdict(result) for result in results])

# Convert results to DataFrame
results_df = retrieve_summary_text_scores(df)
```


```{r}
fix_labels <- function(x) {
  mutate(x,
         generatedBy = case_when(startsWith(generatedBy, "$") ~ str_replace(generatedBy, "^\\$", ""),
                                 TRUE ~ generatedBy),
         prompt_type = case_when(str_detect(generatedBy, "@basic") ~ "Simple",
                                 str_detect(generatedBy, "@decompos") ~ "Decompose",
                                 startsWith(generatedBy, "Human") ~ "Human"),
         chart_language = case_when(str_detect(chart_language, "original") ~ "English",
                                    TRUE ~ chart_language)) |> 
    select(-generatedBy) |> 
    relocate(prompt_type, .after = chart_language)
}

py$results_df |> 
  fix_labels() |>
  group_by(chart_language, prompt_type) |>
  summarise(across(starts_with("rouge") | starts_with("bleu"), mean),
            .groups = "drop") |> 
  pivot_longer(cols = -c(chart_language, prompt_type), names_to = "metric", values_to = "value") |> 
  mutate(type = case_when(str_detect(metric, "rouge") ~ "ROUGE",
                          str_detect(metric, "bleu") ~ "BLEU"),
         value = txtRound(value, digits = 2)) |>
  filter(metric %in% c("rouge_l_f", "bleu_score")) |>
  arrange(chart_language, type, prompt_type) |>
  tidyHtmlTable(value = value,
                rnames = prompt_type,
                rgroup = type,
                header = chart_language,
                caption = "ROUGE-L F1 and BLEU scores for generated summaries per language and type")
```

# Review ratings

```{r}
no_reviewers <- ortho_reviews |> count(reviewer) |> nrow()
no_english_reviews <- ortho_reviews |> filter(chart_language == "original") |> count(reviewer) |> nrow()
no_swedish_reviews <- ortho_reviews |> filter(chart_language == "Swedish") |> count(reviewer) |> nrow()

score <- list(
  overall = ortho_reviews |> pull(overall) |> mean(),
  overall_english = ortho_reviews |> filter(chart_language == "original") |> pull(overall) |> mean(),
  overall_swedish = ortho_reviews |> filter(chart_language == "Swedish") |> pull(overall) |> mean()
) |> 
  sapply(txtRound, digits = 1, simplify = FALSE)
```

We have `r nrow(ortho_reviews)` ratings from `r no_reviewers` reviewers. For English charts we have a total of `r no_english_reviews` reviewers, while for Swedish charts we have `r no_swedish_reviews` reviewers The overall rating is `r score$overall`, while the average rating for English charts is `r score$overall_english` and for Swedish charts `r score$overall_swedish`.

```{r radar_data}
radar_data <- ortho_reviews |> 
  fix_labels() |> 
  select(-version, -ends_with("Comment"), -hallucinations) |> 
  pivot_longer(cols = where(is.integer), names_to = "metric", values_to = "value") |>
  group_by(chart_language, prompt_type, metric) |>
  summarise(value = mean(value, na.rm =TRUE), .groups = "drop") |> 
  mutate(metric = case_when(metric == "hospitalCourse" ~ "Hospital course",
                            metric == "medicalHistory" ~ "Medical history",
                            metric == "followUp" ~ "Follow-up",
                            TRUE ~ Hmisc::capitalize(metric))) |> 
  pivot_wider(names_from = metric, values_from = value)

max_min <- radar_data |> 
  select(where(is.numeric)) |> 
  apply(2, function(x) c(4, 1)) |> 
  as.data.frame()

# Combine max, min, and actual data for radar chart
radar_data <- bind_rows(max_min, 
                        radar_data)
```

```{r}
library(fmsb)

plot_radar <- function(x, language) {
  data <- x |> 
    filter(chart_language == language | is.na(chart_language)) |> 
    mutate(order = case_when(is.na(prompt_type) ~ 1,
                             prompt_type == "Human" ~ 2,
                             TRUE ~ 10)) |> 
    arrange(order) |>
    select(-order, -chart_language)
    
  legends <- data$prompt_type |> 
    na.omit() |> 
    unique()
  
  main_colors <- RColorBrewer::brewer.pal(8, "Set2")[1:length(legends)] |>
    col2rgb() |> 
    t()
  colors_border <- rgb(main_colors, alpha = 0.9*255, maxColorValue = 255)
  colors_in <- rgb(main_colors, alpha = 0.4*255, maxColorValue = 255)
  
  data |> 
    select(-prompt_type) |> 
    radarchart(axistype = 1,
               maxmin = TRUE,
               # Customize the polygon colors
               pcol = colors_border,
               pfcol = colors_in,
               plwd = 4,
               # Customize the grid colors
               cglcol = "grey", 
               cglty = 1, 
               axislabcol = "grey", 
               caxislabels = seq(0, 5, 1), 
               cglwd = 0.8,
               # Customize labels
               vlcex = 0.8,
               title = language,
    )
  
  par(xpd = TRUE)
  legend(c(0.5,1), 
         legend = legends, 
         col = colors_border,
         pch = 20, 
         bty = "n",
         cex = 0.8)
}

per_language_radar <- function(x) {
  languages <- x$chart_language |> 
    na.omit() |> 
    unique()
  
  # Split the screen into multiple columns (one per language)
  org_par <- par(mfrow = c(1, length(languages)),
                 mar = rep(0.8, 4),  # Outer margins for the overall plot space
                 oma = rep(0.2, 4))  # Outer margins for the overall plot space
  on.exit(par(org_par))  # Reset to original layout
  
  for (language in languages) {
    plot_radar(x, language)
  }
}
```

# Medical accuracy

```{r, fig.height=6, fig.width=16}
radar_data |> 
  select(chart_language, 
         prompt_type, 
         Diagnosis,
         `Medical history`,
         `Hospital course`,
         `Follow-up`) |> 
  per_language_radar()
```


# Linguistic qualities

```{r, fig.height=6, fig.width=16}
radar_data |> 
  select(chart_language, 
         prompt_type, 
         Conciseness,
         Completeness,
         Language,
         Clarity) |> 
  per_language_radar()
```